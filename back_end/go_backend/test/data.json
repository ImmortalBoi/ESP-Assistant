{
  "code": "\n\n#define CONFIG_ESP32_COREDUMP_DATA_FORMAT_ELF\n#define CONFIG_ESP32_COREDUMP_ENABLE\n#define THINGNAME \"ESP32_AWStest1\"  //change this\n#define AWS_IOT_PUBLISH_TOPIC \"esp32/pub\"\n#define AWS_IOT_SUBSCRIBE_TOPIC \"esp32/sub\"\n\n//Static-Libraries:\n#include \u003cWebServer.h\u003e\n#include \u003curi/UriBraces.h\u003e\n#include \u003cUpdate.h\u003e\n#include \u003cWiFi.h\u003e\n#include \u003cHTTPClient.h\u003e\n#include \u003cPreferences.h\u003e\n#include \u003cPubSubClient.h\u003e\n#include \u003cArduinoJson.h\u003e\n#include \u003cESP32Servo.h\u003e\n\n// Program Instances \u0026 Global Values:\nPreferences preferences;\nWebServer server(80);\nWiFiClientSecure espClient = WiFiClientSecure();\nHTTPClient http;\nPubSubClient client(espClient);\nString fileURL = \"http://esp32-assistant-bucket.s3.eu-central-1.amazonaws.com/Container/dist/sketch.ino.bin\";\nlong contentLength = 0;\nbool isValidContentType = false;\nStaticJsonDocument\u003c200\u003e receivedJson;\nServo serve;\nint pos = 0; \n\n\nconst char AWS_IOT_ENDPOINT[] = \"a2a8tevfyn336a-ats.iot.eu-north-1.amazonaws.com\";  //change this\n\n// Amazon Root CA 1\nstatic const char AWS_CERT_CA[] PROGMEM = R\"EOF(\n-----BEGIN CERTIFICATE-----\nMIIDQTCCAimgAwIBAgITBmyfz5m/jAo54vB4ikPmljZbyjANBgkqhkiG9w0BAQsF\nADA5MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRkwFwYDVQQDExBBbWF6\nb24gUm9vdCBDQSAxMB4XDTE1MDUyNjAwMDAwMFoXDTM4MDExNzAwMDAwMFowOTEL\nMAkGA1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEZMBcGA1UEAxMQQW1hem9uIFJv\nb3QgQ0EgMTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALJ4gHHKeNXj\nca9HgFB0fW7Y14h29Jlo91ghYPl0hAEvrAIthtOgQ3pOsqTQNroBvo3bSMgHFzZM\n9O6II8c+6zf1tRn4SWiw3te5djgdYZ6k/oI2peVKVuRF4fn9tBb6dNqcmzU5L/qw\nIFAGbHrQgLKm+a/sRxmPUDgH3KKHOVj4utWp+UhnMJbulHheb4mjUcAwhmahRWa6\nVOujw5H5SNz/0egwLX0tdHA114gk957EWW67c4cX8jJGKLhD+rcdqsq08p8kDi1L\n93FcXmn/6pUCyziKrlA4b9v7LWIbxcceVOF34GfID5yHI9Y/QCB/IIDEgEw+OyQm\njgSubJrIqg0CAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMC\nAYYwHQYDVR0OBBYEFIQYzIU07LwMlJQuCFmcx7IQTgoIMA0GCSqGSIb3DQEBCwUA\nA4IBAQCY8jdaQZChGsV2USggNiMOruYou6r4lK5IpDB/G/wkjUu0yKGX9rbxenDI\nU5PMCCjjmCXPI6T53iHTfIUJrU6adTrCC2qJeHZERxhlbI1Bjjt/msv0tadQ1wUs\nN+gDS63pYaACbvXy8MWy7Vu33PqUXHeeE6V/Uq2V8viTO96LXFvKWlJbYK8U90vv\no/ufQJVtMVT8QtPHRh8jrdkPSHCa2XV4cdFyQzR1bldZwgJcJmApzyMZFo6IQ6XU\n5MsI+yMRQ+hDKXJioaldXgjUkK642M4UwtBV8ob2xJNDd2ZhwLnoQdeXeGADbkpy\nrqXRfboQnoZsG4q5WTP468SQvvG5\n-----END CERTIFICATE-----\n)EOF\";\n\n// Device Certificate                                               //change this\nstatic const char AWS_CERT_CRT[] PROGMEM = R\"KEY(\n-----BEGIN CERTIFICATE-----\nMIIDWTCCAkGgAwIBAgIUZrjF2wox1xChcK8vj18KQd9FaiswDQYJKoZIhvcNAQEL\nBQAwTTFLMEkGA1UECwxCQW1hem9uIFdlYiBTZXJ2aWNlcyBPPUFtYXpvbi5jb20g\nSW5jLiBMPVNlYXR0bGUgU1Q9V2FzaGluZ3RvbiBDPVVTMB4XDTI0MDMwOTIwMTEy\nMFoXDTQ5MTIzMTIzNTk1OVowHjEcMBoGA1UEAwwTQVdTIElvVCBDZXJ0aWZpY2F0\nZTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAODSrbvUCZpkO/G+6eFW\nq6glIWQS9kPg5m+xCewciPJrbnV5erZD7bQSvd37nsAUUWPdMt2qNAkin89Yo5LG\n8UhCs6reCrbGpSktr2SBVitWFvi9z35M6EYEwpMlNJtPrJk3ZrceZlYuLLqSITMr\n2JYF6JLiwfl5Y0Q+HpeeBOSrmzW7kjf8PBW1FFER01lSCF0QQ1Mbc6XxjgzlPdii\noss8AwbdVMTh9rtpyyRTozKLwgmYQboB+EUdhy/RQzV7QcnXqxAXoJn9nCbkMBZX\ndAxMpM4XQFVPKvW25Kyerz1x7kmGiRC8JdWIYlngo2kNQG56Aq8beTB21W3r7MJf\nNmsCAwEAAaNgMF4wHwYDVR0jBBgwFoAUhBA/F3ZORDKap7JNBRZ8I4ZEQzkwHQYD\nVR0OBBYEFBHyTkZpJ9cjW0t5fTPmMmB5wWdyMAwGA1UdEwEB/wQCMAAwDgYDVR0P\nAQH/BAQDAgeAMA0GCSqGSIb3DQEBCwUAA4IBAQBHXmxTW+j6oDtooAAsiTUriAx4\n+rbl5CuyuXnf3qvXN0LvOr9X4O0+965pcYzguh90KH5qNQpZ6VIFviW31Q/1cjbt\nHlBaXjXB1WKidBrsg3gi4+GF5uCC+Ir8dmKBRZ/Dq6eXXo45wvobFBvEfMisevlW\nPD/qfyf51rfMMu8uMkWGsJdciK7NDUdyffodxWSS8yCfK1CtlFt2igwmD3z6ZTwu\nrjKpZNA0r3JzSlwxvpUp+5VwvzefEwjtpuIpZLT/yUtxeit/PDk9ckqfa+RWDj/+\nsGgzZrvMGn9wDYcXTrLdUgMGdbQDa14n1FbUMyjk6fUtHhUi16DZzXDJCw0d\n-----END CERTIFICATE-----\n)KEY\";\n\n// Device Private Key                                               //change this\nstatic const char AWS_CERT_PRIVATE[] PROGMEM = R\"KEY(\n-----BEGIN RSA PRIVATE KEY-----\nMIIEpAIBAAKCAQEA4NKtu9QJmmQ78b7p4VarqCUhZBL2Q+Dmb7EJ7ByI8mtudXl6\ntkPttBK93fuewBRRY90y3ao0CSKfz1ijksbxSEKzqt4KtsalKS2vZIFWK1YW+L3P\nfkzoRgTCkyU0m0+smTdmtx5mVi4supIhMyvYlgXokuLB+XljRD4el54E5KubNbuS\nN/w8FbUUURHTWVIIXRBDUxtzpfGODOU92KKiyzwDBt1UxOH2u2nLJFOjMovCCZhB\nugH4RR2HL9FDNXtByderEBegmf2cJuQwFld0DEykzhdAVU8q9bbkrJ6vPXHuSYaJ\nELwl1YhiWeCjaQ1AbnoCrxt5MHbVbevswl82awIDAQABAoIBAB2+AVnd3T9dj0iV\n9x7mdmMSNm6ky4uDTzjrdOKVi9B2QfCsl31RUzsFV7TsOr4yceoCM157y9KBkB7A\nHTOnuffTSy2JnmU7tlHSR2fGbH3jL7rMcYzF49yPeKY6v9DkI3NJjv8euG8iQKyV\n9GpunIKMWY5FDWBRnL5EcYuhTghqI+UF5JyxKaLV7iW6HSXrQ7dNTlD8Wuc+6kEn\niG60uNvCbR1p57zN16wgLEk809IihUJstuIgHiz2Obq/AYk0mLXvOhXSsTbyo2aW\nz6OVYhECnB7DwMn6Vqmt+JZ2qsuLpkRPoDttoHjZ0JGEUXAKcuUOTbivlcDlSivP\nPvPl4YECgYEA+EDJ14cJRm16LEWWvHfAyNsvaBjtpgKg7fdtdk8wJ1jNxfCZZSP5\ndkNsT5OxdRTFH2KctqGCarYsdecftX3Zn6/IDLmpBxpTBjURxicyg/bhcAn5aHDp\n00kikwT7JPxLPd5R+HZ/0XYuSkealpP0GVmJ5zyQWQXeBfjl+6bXySECgYEA59a2\n+yk/x4kuLkU6ZjCg958jmVBsKvSUMraiEw9oODqlQFb1a0Rh9leD0Z/WLPdDMtWx\n+3N4on2gf0X0kmBYaJE797b2c+RMj6YMk1HLL44qJ3A0TA9LhFGO4MoW5RLW6ZWc\nAwS27dca+3MnyUOIcTWeWm3W8DM/QLDNpAINUgsCgYB3rHvg22b8PYBc4TsWJcCY\n0xjaXNILak78CIALPYdgIG4qEp9P43S5ry0Ce5dbcqTISXh0jg1ZtfJe8AkYK9AC\nK/ILOGEkXGtTnbewx2qRtSzeHuDNmUkPIr15FDihjsIS1B694Roi9o7AHh6GolJU\n+hYBk++eCrcKN/9ePgLeIQKBgQChQg86uiFb2EZf9tU9GVwNgQrQ7EigxEiE0dYA\nLfpPCjPBgfro5sLBB3RwDZ563m5GYK+Q+GuTkpBdlrocSpmT+llc302jpMvAKz6a\nBg2vgVI+5mPp98WOPvCD2O193tHP3bmLu+7FlpZ1Ck9FRg0UubfwrHAR2YOIqrIO\n/0JmqwKBgQC3mjLFSyYx0Lvo7/7kYBkuUO08Ex2KYrQyVQjM/IvLUAAsv8/ra7gr\nG+XOJHSoQXFqFKLY3iALTsRmT11mw8Djv45TNkRmOf0LWYP/O+RuYK3gSkfuGxij\njbgOjEhRBx1TyhC9K85/f+OufgkPSEYYuTL9dE+SItftG+TBNpWMsQ==\n-----END RSA PRIVATE KEY-----\n)KEY\";\n\n// OTA Logic\nvoid execOTA() {\n  Serial.println(\"Connecting to: \" + String(fileURL));\n\n  http.begin(fileURL); // Specify the URL\n  int httpCode = http.GET(); // Make the request\n\n  if (httpCode \u003e 0) { // Check for the returning code\n    // Get the payload\n    Stream\u0026 payload = http.getStream();\n\n    // Check if the HTTP Response is 200\n    if (httpCode == HTTP_CODE_OK) {\n      // Check if there is enough to OTA Update\n      bool canBegin = Update.begin(http.getSize());\n\n      // If yes, begin\n      if (canBegin) {\n        Serial.println(\"Begin OTA. This may take 2 - 5 mins to complete. Things might be quite for a while.. Patience!\");\n        size_t written = Update.writeStream(payload);\n\n        if (written == http.getSize()) {\n          Serial.println(\"Written : \" + String(written) + \" successfully\");\n        } else {\n          Serial.println(\"Written only : \" + String(written) + \"/\" + String(http.getSize()) + \". Retry?\");\n        }\n\n        if (Update.end()) {\n          Serial.println(\"OTA done!\");\n          if (Update.isFinished()) {\n            Serial.println(\"Update successfully completed. Rebooting.\");\n            ESP.restart();\n          } else {\n            Serial.println(\"Update not finished? Something went wrong!\");\n          }\n        } else {\n          Serial.println(\"Error Occurred. Error #: \" + String(Update.getError()));\n        }\n      } else {\n        // not enough space to begin OTA\n        Serial.println(\"Not enough space to begin OTA\");\n      }\n    } else {\n      Serial.println(\"Got a non 200 status code from server. Exiting OTA Update.\");\n    }\n  } else {\n    Serial.println(\"Failed to connect to server. Exiting OTA Update.\");\n  }\n\n  http.end(); // End the connection\n}\n\nvoid wifiSetup() {\n  String wifiIndex = \"\";\n  String pass = \"\";\n  unsigned long previousMillis = 0;\n  const long interval = 10000;\n  if (preferences.getString(\"wifiIndex\", \"\") != \"\") {  //fetch wifi credis from flash mem\n    Serial.println(\"Fetching Wifi\");\n\n    wifiIndex = preferences.getString(\"wifiIndex\", \"\");\n    pass = preferences.getString(\"pass\", \"\");\n\n    WiFi.begin(wifiIndex, pass, 6);\n\n    Serial.print(\"Connecting to WiFi\");\n\n    while (WiFi.status() != WL_CONNECTED) {\n      unsigned long currentMillis = millis();\n      delay(1000);\n      Serial.print(\".\");\n      if (currentMillis - previousMillis \u003e= interval) {\n        preferences.putString(\"wifiIndex\", \"\");\n        preferences.putString(\"pass\", \"\");\n        wifiSetup();\n      }\n    }\n    Serial.println(\"Connected!\");\n    return;\n  }\n  String password_AP = \"12345678\";\n  String ssid_AP = \"ESP32\";\n  WiFi.softAP(ssid_AP, password_AP);\n  Serial.println(\"Created AP\");\n  Serial.print(\"ESP AP IP: \");\n  Serial.println(WiFi.softAPIP());\n\n  server.on(UriBraces(\"/reply\"), HTTP_GET, []() {\n    Serial.println(\"Request sent\");\n    int n = WiFi.scanNetworks();\n    String json;\n    StaticJsonDocument\u003c200\u003e doc;\n    JsonArray wifiArray = doc.createNestedArray(\"wifi\");\n    if (n == 0) {\n      Serial.println(\"no networks found\");\n    } else {\n      for (int i = 0; i \u003c n; ++i) {\n        wifiArray.add(WiFi.SSID(i));  // Add the copied string to the JSON array\n      }\n\n      serializeJson(doc, json);\n\n      server.send(200, \"application/json\", json);\n      WiFi.scanDelete();  // Delete the old scan results\n    }\n  });\n\n  server.on(UriBraces(\"/wifi/{}/pass/{}\"), HTTP_GET, []() {\n    Serial.println(\"input Recieved\");\n    String wifiIndex = server.pathArg(0);\n    String pass = server.pathArg(1);\n    wifiIndex.replace(\"%20\", \" \");\n    Serial.println(wifiIndex);\n    Serial.println(pass);\n\n    WiFi.begin(wifiIndex, pass, 6);\n    Serial.print(\"Connecting to WiFi\");\n\n    while (WiFi.status() != WL_CONNECTED) {\n      delay(1000);\n      Serial.print(\".\");\n    }\n    Serial.println(\"Connected!\");\n    preferences.putString(\"wifiIndex\", wifiIndex);\n    preferences.putString(\"pass\", pass);\n  });\n\n  server.begin();\n  Serial.println(\"HTTP server started\");\n  while (WiFi.status() != WL_CONNECTED) {\n    if (WiFi.softAPgetStationNum() \u003e 0) {\n      Serial.println(\"Client connected\");\n    }\n    server.handleClient();\n    delay(3000);\n  }\n}\n\nvoid connectAWS() {\n  // Configure WiFiClientSecure to use the AWS IoT device credentials\n  espClient.setCACert(AWS_CERT_CA);\n  espClient.setCertificate(AWS_CERT_CRT);\n  espClient.setPrivateKey(AWS_CERT_PRIVATE);\n\n  // Connect to the MQTT broker on the AWS endpoint we defined earlier\n  client.setServer(AWS_IOT_ENDPOINT, 8883);\n\n  // Create a message handler\n  client.setCallback(messageHandler);\n\n  Serial.println(\"Connecting to AWS IoT\");\n\n  while (!client.connect(THINGNAME)) {\n    Serial.print(\".\");\n    delay(100);\n  }\n\n  if (!client.connected()) {\n    Serial.println(\"AWS IoT Timeout!\");\n    return;\n  }\n\n  // Subscribe to a topic\n  client.subscribe(AWS_IOT_SUBSCRIBE_TOPIC);\n  client.subscribe(\"esp32/led\");\n  Serial.println(\"AWS IoT Connected!\");\n}\n\nvoid messageHandler(char* topic, byte* payload, unsigned int length) { \n  Serial.print(\"incoming: \");\n  Serial.println(topic);\n  deserializeJson(receivedJson, payload);\n  const char* type = receivedJson[\"type\"];\n  String typ(type);\n  const uint8_t value = receivedJson[\"value\"];\n  const uint8_t pin = receivedJson[\"pin\"];\n  if (typ.equals(\"led\")) { \n    Serial.println(\"led called\");\n    Serial.println(value);\n    Serial.println(pin);\n    digitalWrite(pin, value);\n  }\n  if(typ.equals(\"update\")){\n    Serial.println(\"update called\");\n    execOTA();\n  }\n}\n\n\n\nvoid publishMessage() { \n  StaticJsonDocument\u003c200\u003e sentJson;\n  sentJson[\"type\"] = \"led\";\n  sentJson[\"value\"] = 1;\n  sentJson[\"pin\"] = 2;\n  char jsonBuffer[512];\n  serializeJson(sentJson, jsonBuffer); \n  Serial.println(\"Message published!\");\n  client.publish(AWS_IOT_PUBLISH_TOPIC, jsonBuffer);\n}\n\n\n\nvoid customFunc() { \n  digitalWrite(2, HIGH);\n  delay(1000);\n  digitalWrite(2, LOW);\n  delay(1000);\n  for (pos = 0; pos \u003c= 180; pos += 1) {\n    serve.write(pos);\n    delay(15);\n  }\n  for (pos = 180; pos \u003e= 0; pos -= 1) {\n    serve.write(pos);\n    delay(15);\n  }\n}\n\n\n\nvoid setup() {\n  Serial.begin(115200);\n  WiFi.mode(WIFI_AP_STA);\n  pinMode(2, OUTPUT);\n  serve.attach(5);\n  WiFi.disconnect();\n  preferences.begin(\"my-app\", false);\n  wifiSetup();\n  connectAWS();\n}\n \n\n\nvoid loop() {\n  client.loop();\n  if (1 == receivedJson[\"active\"]) {\n    customFunc();\n  }\n  if (WiFi.status() != WL_CONNECTED) {\n    Serial.println(\"Connecting to wifi...\");\n    delay(5000);\n    if (WiFi.status() == WL_CONNECTED) {\n      Serial.println(\"Connected...\");\n      connectAWS();\n    }\n    delay(1000);\n  }\n}\n",
  "compileRequestResp": "{\"msg\":\"Bin files uploaded successfully.\"}\n",
  "customFunction": "void customFunc() { \n  digitalWrite(2, HIGH);\n  delay(1000);\n  digitalWrite(2, LOW);\n  delay(1000);\n  for (pos = 0; pos \u003c= 180; pos += 1) {\n    serve.write(pos);\n    delay(15);\n  }\n  for (pos = 180; pos \u003e= 0; pos -= 1) {\n    serve.write(pos);\n    delay(15);\n  }\n}\n\n",
  "globalDeclarations": "Preferences preferences;\nWebServer server(80);\nWiFiClientSecure espClient = WiFiClientSecure();\nHTTPClient http;\nPubSubClient client(espClient);\nString fileURL = \"http://esp32-assistant-bucket.s3.eu-central-1.amazonaws.com/Container/dist/sketch.ino.bin\";\nlong contentLength = 0;\nbool isValidContentType = false;\nStaticJsonDocument\u003c200\u003e receivedJson;\nServo serve;\nint pos = 0; \n",
  "libraries": ["WiFi", "HTTPClient", "Preferences", "PubSubClient", "ArduinoJson", "ESP32Servo"],
  "messageHandler": "void messageHandler(char* topic, byte* payload, unsigned int length) { \n  Serial.print(\"incoming: \");\n  Serial.println(topic);\n  deserializeJson(receivedJson, payload);\n  const char* type = receivedJson[\"type\"];\n  String typ(type);\n  const uint8_t value = receivedJson[\"value\"];\n  const uint8_t pin = receivedJson[\"pin\"];\n  if (typ.equals(\"led\")) { \n    Serial.println(\"led called\");\n    Serial.println(value);\n    Serial.println(pin);\n    digitalWrite(pin, value);\n  }\n  if(typ.equals(\"update\")){\n    Serial.println(\"update called\");\n    execOTA();\n  }\n}\n\n",
  "publishMessage": "void publishMessage() { \n  StaticJsonDocument\u003c200\u003e sentJson;\n  sentJson[\"type\"] = \"led\";\n  sentJson[\"value\"] = 1;\n  sentJson[\"pin\"] = 2;\n  char jsonBuffer[512];\n  serializeJson(sentJson, jsonBuffer); \n  Serial.println(\"Message published!\");\n  client.publish(AWS_IOT_PUBLISH_TOPIC, jsonBuffer);\n}\n\n",
  "reply": "##Generated Libraries \n*   WiFi.h\n*   HTTPClient.h\n*   Preferences.h\n*   PubSubClient.h\n*   ArduinoJson.h\n*   ESP32Servo.h \n\n##Global Variables\n```cpp\nPreferences preferences;\nWebServer server(80);\nWiFiClientSecure espClient = WiFiClientSecure();\nHTTPClient http;\nPubSubClient client(espClient);\nString fileURL = \"http://esp32-assistant-bucket.s3.eu-central-1.amazonaws.com/Container/dist/sketch.ino.bin\";\nlong contentLength = 0;\nbool isValidContentType = false;\nStaticJsonDocument\u003c200\u003e receivedJson;\nServo serve;\nint pos = 0; \n```\n##Custom Function Function\n```cpp\nvoid customFunc() { \n  digitalWrite(2, HIGH);\n  delay(1000);\n  digitalWrite(2, LOW);\n  delay(1000);\n  for (pos = 0; pos \u003c= 180; pos += 1) {\n    serve.write(pos);\n    delay(15);\n  }\n  for (pos = 180; pos \u003e= 0; pos -= 1) {\n    serve.write(pos);\n    delay(15);\n  }\n}\n```\n##Publish Message Function\n```cpp\nvoid publishMessage() { \n  StaticJsonDocument\u003c200\u003e sentJson;\n  sentJson[\"type\"] = \"led\";\n  sentJson[\"value\"] = 1;\n  sentJson[\"pin\"] = 2;\n  char jsonBuffer[512];\n  serializeJson(sentJson, jsonBuffer); \n  Serial.println(\"Message published!\");\n  client.publish(AWS_IOT_PUBLISH_TOPIC, jsonBuffer);\n}\n```\n##Message Handler Function\n```cpp\nvoid messageHandler(char* topic, byte* payload, unsigned int length) { \n  Serial.print(\"incoming: \");\n  Serial.println(topic);\n  deserializeJson(receivedJson, payload);\n  const char* type = receivedJson[\"type\"];\n  String typ(type);\n  const uint8_t value = receivedJson[\"value\"];\n  const uint8_t pin = receivedJson[\"pin\"];\n  if (typ.equals(\"led\")) { \n    Serial.println(\"led called\");\n    Serial.println(value);\n    Serial.println(pin);\n    digitalWrite(pin, value);\n  }\n  if(typ.equals(\"update\")){\n    Serial.println(\"update called\");\n    execOTA();\n  }\n}\n```\n##Setup Function\n```cpp\nvoid setup() {\n  Serial.begin(115200);\n  WiFi.mode(WIFI_AP_STA);\n  pinMode(2, OUTPUT);\n  serve.attach(5);\n  WiFi.disconnect();\n  preferences.begin(\"my-app\", false);\n  wifiSetup();\n  connectAWS();\n}\n``` \n",
  "setup": "void setup() {\n  Serial.begin(115200);\n  WiFi.mode(WIFI_AP_STA);\n  pinMode(2, OUTPUT);\n  serve.attach(5);\n  WiFi.disconnect();\n  preferences.begin(\"my-app\", false);\n  wifiSetup();\n  connectAWS();\n}\n \n"
}

{
  "code": "\n\n#define CONFIG_ESP32_COREDUMP_DATA_FORMAT_ELF\n#define CONFIG_ESP32_COREDUMP_ENABLE\n#define THINGNAME \"ESP32_AWStest1\"  //change this\n#define AWS_IOT_PUBLISH_TOPIC \"esp32/pub\"\n#define AWS_IOT_SUBSCRIBE_TOPIC \"esp32/sub\"\n\n//Static-Libraries:\n#include \u003cWebServer.h\u003e\n#include \u003curi/UriBraces.h\u003e\n#include \u003cUpdate.h\u003e\n#include \u003cWiFi.h\u003e\n#include \u003cHTTPClient.h\u003e\n#include \u003cPreferences.h\u003e\n#include \u003cPubSubClient.h\u003e\n#include \u003cArduinoJson.h\u003e\n#include \u003cESP32Servo.h\u003e\n\n// Program Instances \u0026 Global Values:\nPreferences preferences;\nWebServer server(80);\nWiFiClientSecure espClient = WiFiClientSecure();\nHTTPClient http;\nPubSubClient client(espClient);\nString fileURL = \"https://esp32-assistant-bucket.s3.eu-central-1.amazonaws.com/Container/dist/testing.ino.bin\";\nlong contentLength = 0;\nbool isValidContentType = false;\nStaticJsonDocument\u003c200\u003e receivedJson;\nServo serve;\nint pos = 0; \n\nconst char AWS_IOT_ENDPOINT[] = \"a2a8tevfyn336a-ats.iot.eu-central-1.amazonaws.com\";  //change this\n\n// Amazon Root CA 1\nstatic const char AWS_CERT_CA[] PROGMEM = R\"EOF(\n-----BEGIN CERTIFICATE-----\nMIIDQTCCAimgAwIBAgITBmyfz5m/jAo54vB4ikPmljZbyjANBgkqhkiG9w0BAQsF\nADA5MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRkwFwYDVQQDExBBbWF6\nb24gUm9vdCBDQSAxMB4XDTE1MDUyNjAwMDAwMFoXDTM4MDExNzAwMDAwMFowOTEL\nMAkGA1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEZMBcGA1UEAxMQQW1hem9uIFJv\nb3QgQ0EgMTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALJ4gHHKeNXj\nca9HgFB0fW7Y14h29Jlo91ghYPl0hAEvrAIthtOgQ3pOsqTQNroBvo3bSMgHFzZM\n9O6II8c+6zf1tRn4SWiw3te5djgdYZ6k/oI2peVKVuRF4fn9tBb6dNqcmzU5L/qw\nIFAGbHrQgLKm+a/sRxmPUDgH3KKHOVj4utWp+UhnMJbulHheb4mjUcAwhmahRWa6\nVOujw5H5SNz/0egwLX0tdHA114gk957EWW67c4cX8jJGKLhD+rcdqsq08p8kDi1L\n93FcXmn/6pUCyziKrlA4b9v7LWIbxcceVOF34GfID5yHI9Y/QCB/IIDEgEw+OyQm\njgSubJrIqg0CAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMC\nAYYwHQYDVR0OBBYEFIQYzIU07LwMlJQuCFmcx7IQTgoIMA0GCSqGSIb3DQEBCwUA\nA4IBAQCY8jdaQZChGsV2USggNiMOruYou6r4lK5IpDB/G/wkjUu0yKGX9rbxenDI\nU5PMCCjjmCXPI6T53iHTfIUJrU6adTrCC2qJeHZERxhlbI1Bjjt/msv0tadQ1wUs\nN+gDS63pYaACbvXy8MWy7Vu33PqUXHeeE6V/Uq2V8viTO96LXFvKWlJbYK8U90vv\no/ufQJVtMVT8QtPHRh8jrdkPSHCa2XV4cdFyQzR1bldZwgJcJmApzyMZFo6IQ6XU\n5MsI+yMRQ+hDKXJioaldXgjUkK642M4UwtBV8ob2xJNDd2ZhwLnoQdeXeGADbkpy\nrqXRfboQnoZsG4q5WTP468SQvvG5\n-----END CERTIFICATE-----\n)EOF\";\n\n// Device Certificate                                               //change this\nstatic const char AWS_CERT_CRT[] PROGMEM = R\"KEY(\n-----BEGIN CERTIFICATE-----\nMIIDWjCCAkKgAwIBAgIVAMSqUAwpr08dG80ZJn1eeEUzq4B9MA0GCSqGSIb3DQEB\nCwUAME0xSzBJBgNVBAsMQkFtYXpvbiBXZWIgU2VydmljZXMgTz1BbWF6b24uY29t\nIEluYy4gTD1TZWF0dGxlIFNUPVdhc2hpbmd0b24gQz1VUzAeFw0yNDA0MTUxMTAz\nMDNaFw00OTEyMzEyMzU5NTlaMB4xHDAaBgNVBAMME0FXUyBJb1QgQ2VydGlmaWNh\ndGUwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQC7PuubmI79QhgfiPQ4\naHwBT9Azz/OdRyxQ3T7uNa5XrSbyB+T1UXPdscJKqEIZmdSE9Y3+9u4hOdLSXjvl\nKMC7RTiiDadbisg1uMbosPTdMxciuT5mFu+ALU3I622yXUnBshQKq+P9WSaQ/kxc\nqkUbbc51PWghSNjnE2ZWRYNSlODuul6ZEozh7AixDRxyieJfmNpF8Fkbnob3MQdm\n3PXHEVuA/wu5kgoHUh7pPNGoQG9BW1Gr1X+NY5q8doySIpQ7wn1/omyJ3E12UkD6\nfxo0ZvOjjTWtYyg9qSsNdCT8VL10pm66qTuor+hfmECsIAP3nKsF+7dEQhQ9Sjb+\nsblhAgMBAAGjYDBeMB8GA1UdIwQYMBaAFN7+R/5xvt+5bL8uL/P3+YpNkxB4MB0G\nA1UdDgQWBBTWWGGW04x7Q7O39fYGBXCAyTqEhjAMBgNVHRMBAf8EAjAAMA4GA1Ud\nDwEB/wQEAwIHgDANBgkqhkiG9w0BAQsFAAOCAQEAb703eOFj/MsyqyaGnR7cwS7Y\nUcCT0rf3WrZY5G5QzfzzV69WbKDefJlxYaLI2J0xhOFeyOdArBRDwPNhoYircIrR\nNQNXmkOHevazMFGtgQ9/n10FrMv3MBCpE5sHeHwQR5ZE4RVTACqWaYNE2+mx3KOz\nM6Jrd7QGSeYvTqjPitevftbmOphURJpGPnnyr7OLRNgBJwneimjY6StF86vdbRav\neRIJsMxCLjSiobcB1n7C7UJVlyiA+JJiWikVB/k/uJgr1jynt+tlSCYK5KwDcfKD\nksui+Zehr1W4mCLXyrydb/7PdEx1N8OQZszRv6smWW5UKPSVo8M4IIPm41OsDQ==\n-----END CERTIFICATE-----\n)KEY\";\n\n// Device Private Key                                               //change this\nstatic const char AWS_CERT_PRIVATE[] PROGMEM = R\"KEY(\n-----BEGIN RSA PRIVATE KEY-----\nMIIEowIBAAKCAQEAuz7rm5iO/UIYH4j0OGh8AU/QM8/znUcsUN0+7jWuV60m8gfk\n9VFz3bHCSqhCGZnUhPWN/vbuITnS0l475SjAu0U4og2nW4rINbjG6LD03TMXIrk+\nZhbvgC1NyOttsl1JwbIUCqvj/VkmkP5MXKpFG23OdT1oIUjY5xNmVkWDUpTg7rpe\nmRKM4ewIsQ0cconiX5jaRfBZG56G9zEHZtz1xxFbgP8LuZIKB1Ie6TzRqEBvQVtR\nq9V/jWOavHaMkiKUO8J9f6JsidxNdlJA+n8aNGbzo401rWMoPakrDXQk/FS9dKZu\nuqk7qK/oX5hArCAD95yrBfu3REIUPUo2/rG5YQIDAQABAoIBAHkUBLJGgh/N/19U\n5ecb2SPYAl+eln8bKNLZXfoXCDd1pftXk3v2QaAXc/Vmu+dmC4A2cK1v6yfdBjA1\n8zEJmyb9adOQVKnjIfdrFmQdGRl4EfvIIUtOhWwy31uOsQ5nOGxhxIfqArEuVrvn\nVGWPTMShyqERJiZvvqIdb01WAccBlaqV94lgfgBTunJfC93+sUrvxu7YLydCXSJs\nM4Ec3YPsQkCmo77GtZrWh3xIE6ItcizWmtzNU6hznT9iSFft+x0Od4NLsqPngBr1\nq8xzBWfYPDts+w4s/4mJiuCpc220EAUiynBEIZ0zfXD6+pUXje9SpL/ZgHb9exaW\nlxcjgAECgYEA8eTZzimMmYzkvpWK1P+FZwKKbfh9rIBSmKq3fBovrbPu6qnnQm3l\n+969NsFAMzjRLJq6VxM5zEqoIV+NL4m6Cy8FIwl1fRjClPYYAzRqtAo8r8o85xWX\nvYHMiU/p3Xl48TXhB9k8g59i6ylutNHDpmuXKH3WgBVdUDLUfTezG2ECgYEAxio/\nFDP79/2he+t8rw5WRHp4CtwKv0OiaNnlQ+/Tk61xorIwnKUfX4s6b9RJgfHsR7MI\nNQPSB298y7rvPJ3Cx5c2BbjDRNBT8Utb8d0KyGuXAyc4tV2GJ29wNS9JqmfDJxrP\nmffFv/16ZoZ3kqR5tKzYGBzk7T1to6xnzCGRXgECgYEAwmrPbFYUvW1yhIOo/B0L\nWYm/PTgVuknBGRdNNh/N5mzSQCWiy8+Mo22Y4qNcOE8YQCN0VXwMXlg63efwkB7A\nOzDljg2SMqNt8VACaMD+ago4UInZfVnrhdMHU+2459s0C5rkbOx7KMc4OA4q/oYC\nHIYpDdBmULfbMhRImQPlnsECgYBHzRLh/Rv09R9HyUF6JFW5pi5MsQHr31O/bgQW\nI5Wj0ppz+uCGQYYmlknsLx0bSk70g7gbjXDSZODw6KC6c+cZbn6SgCmwi1N/AHEm\nJ5M6n1EuQU3Y2TQ8obIkcyfb6JDbYGmMPiyWrf9lmp9EsPewMVhzFDUWiMVrIpLR\ncfA8AQKBgB4u27YDs3T0fPRZVJ4Trc1lDS0CwJNlm9bjE2+pTjiPZ6AmQuAYRuUY\nY3TBoPVutN49vRAI9BcfyVAK0+Zb+lYhX/Ej89mcvbiBz5ucT8IUAaxWEUn6NYBz\n0fSMkFa7mAi+Mu2a7fIrr0WPyP3i+i7hvesOZxLX13iU6I/RTC/1\n-----END RSA PRIVATE KEY-----\n)KEY\";\n\n// OTA Logic\nvoid execOTA() {\n  Serial.println(\"Connecting to: \" + String(fileURL));\n\n  http.begin(fileURL); // Specify the URL\n  int httpCode = http.GET(); // Make the request\n\n  if (httpCode \u003e 0) { // Check for the returning code\n    // Get the payload\n    Stream\u0026 payload = http.getStream();\n\n    // Check if the HTTP Response is 200\n    if (httpCode == HTTP_CODE_OK) {\n      // Check if there is enough to OTA Update\n      bool canBegin = Update.begin(http.getSize());\n\n      // If yes, begin\n      if (canBegin) {\n        Serial.println(\"Begin OTA. This may take 2 - 5 mins to complete. Things might be quite for a while.. Patience!\");\n        size_t written = Update.writeStream(payload);\n\n        if (written == http.getSize()) {\n          Serial.println(\"Written : \" + String(written) + \" successfully\");\n        } else {\n          Serial.println(\"Written only : \" + String(written) + \"/\" + String(http.getSize()) + \". Retry?\");\n        }\n\n        if (Update.end()) {\n          Serial.println(\"OTA done!\");\n          if (Update.isFinished()) {\n            Serial.println(\"Update successfully completed. Rebooting.\");\n            ESP.restart();\n          } else {\n            Serial.println(\"Update not finished? Something went wrong!\");\n          }\n        } else {\n          Serial.println(\"Error Occurred. Error #: \" + String(Update.getError()));\n        }\n      } else {\n        // not enough space to begin OTA\n        Serial.println(\"Not enough space to begin OTA\");\n      }\n    } else {\n      Serial.println(\"Got a non 200 status code from server. Exiting OTA Update.\");\n    }\n  } else {\n    Serial.println(\"Failed to connect to server. Exiting OTA Update.\");\n  }\n\n  http.end(); // End the connection\n}\n\nvoid wifiSetup() {\n  String wifiIndex = \"\";\n  String pass = \"\";\n  unsigned long previousMillis = 0;\n  const long interval = 10000;\n  if (preferences.getString(\"wifiIndex\", \"\") != \"\") {  //fetch wifi credis from flash mem\n    Serial.println(\"Fetching Wifi\");\n\n    wifiIndex = preferences.getString(\"wifiIndex\", \"\");\n    pass = preferences.getString(\"pass\", \"\");\n\n    WiFi.begin(wifiIndex, pass, 6);\n\n    Serial.print(\"Connecting to WiFi\");\n\n    while (WiFi.status() != WL_CONNECTED) {\n      unsigned long currentMillis = millis();\n      delay(1000);\n      Serial.print(\".\");\n      if (currentMillis - previousMillis \u003e= interval) {\n        preferences.putString(\"wifiIndex\", \"\");\n        preferences.putString(\"pass\", \"\");\n        wifiSetup();\n      }\n    }\n    Serial.println(\"Connected!\");\n    return;\n  }\n  String password_AP = \"12345678\";\n  String ssid_AP = \"ESP32\";\n  WiFi.softAP(ssid_AP, password_AP);\n  Serial.println(\"Created AP\");\n  Serial.print(\"ESP AP IP: \");\n  Serial.println(WiFi.softAPIP());\n\n  server.on(UriBraces(\"/reply\"), HTTP_GET, []() {\n    Serial.println(\"Request sent\");\n    int n = WiFi.scanNetworks();\n    String json;\n    StaticJsonDocument\u003c200\u003e doc;\n    JsonArray wifiArray = doc.createNestedArray(\"wifi\");\n    if (n == 0) {\n      Serial.println(\"no networks found\");\n    } else {\n      for (int i = 0; i \u003c n; ++i) {\n        wifiArray.add(WiFi.SSID(i));  // Add the copied string to the JSON array\n      }\n\n      serializeJson(doc, json);\n\n      server.send(200, \"application/json\", json);\n      WiFi.scanDelete();  // Delete the old scan results\n    }\n  });\n\n  server.on(UriBraces(\"/wifi/{}/pass/{}\"), HTTP_GET, []() {\n    Serial.println(\"input Recieved\");\n    String wifiIndex = server.pathArg(0);\n    String pass = server.pathArg(1);\n    wifiIndex.replace(\"%20\", \" \");\n    Serial.println(wifiIndex);\n    Serial.println(pass);\n\n    WiFi.begin(wifiIndex, pass, 6);\n    Serial.print(\"Connecting to WiFi\");\n\n    while (WiFi.status() != WL_CONNECTED) {\n      delay(1000);\n      Serial.print(\".\");\n    }\n    Serial.println(\"Connected!\");\n    preferences.putString(\"wifiIndex\", wifiIndex);\n    preferences.putString(\"pass\", pass);\n  });\n\n  server.begin();\n  Serial.println(\"HTTP server started\");\n  while (WiFi.status() != WL_CONNECTED) {\n    if (WiFi.softAPgetStationNum() \u003e 0) {\n      Serial.println(\"Client connected\");\n    }\n    server.handleClient();\n    delay(3000);\n  }\n}\n\nvoid connectAWS() {\n  // Configure WiFiClientSecure to use the AWS IoT device credentials\n  espClient.setCACert(AWS_CERT_CA);\n  espClient.setCertificate(AWS_CERT_CRT);\n  espClient.setPrivateKey(AWS_CERT_PRIVATE);\n\n  // Connect to the MQTT broker on the AWS endpoint we defined earlier\n  client.setServer(AWS_IOT_ENDPOINT, 8883);\n\n  // Create a message handler\n  client.setCallback(messageHandler);\n\n  Serial.println(\"Connecting to AWS IoT\");\n\n  while (!client.connect(THINGNAME)) {\n    Serial.print(\".\");\n    delay(100);\n  }\n\n  if (!client.connected()) {\n    Serial.println(\"AWS IoT Timeout!\");\n    return;\n  }\n\n  // Subscribe to a topic\n  client.subscribe(AWS_IOT_SUBSCRIBE_TOPIC);\n  client.subscribe(\"esp32/led\");\n  Serial.println(\"AWS IoT Connected!\");\n}\n\nvoid messageHandler(char* topic, byte* payload, unsigned int length) {\n  deserializeJson(receivedJson, payload);\n  const char* type = receivedJson[\"type\"];\n  String typ(type);\n  const uint8_t value = receivedJson[\"value\"];\n  const uint8_t pin = receivedJson[\"pin\"];\n  if (typ.equals(\"led\")) {\n    digitalWrite(pin, value);\n  }\n  if (typ.equals(\"servo\")) {\n    serve.write(value);\n  }\n  if(typ.equals(\"update\")){\n    execOTA();\n  }\n}\n\n\n\nvoid publishMessage() {\n  StaticJsonDocument\u003c200\u003e sentJson;\n  sentJson[\"type\"] = \"led\";\n  sentJson[\"value\"] = 1;\n  sentJson[\"pin\"] = 2;\n  char jsonBuffer[512];\n  serializeJson(sentJson, jsonBuffer); \n  client.publish(AWS_IOT_PUBLISH_TOPIC, jsonBuffer);\n}\n\n\n\nvoid customFunc() {\n  digitalWrite(2, HIGH);\n  delay(1000);\n  digitalWrite(2, LOW);\n  delay(1000);\n  for (pos = 0; pos \u003c= 180; pos += 1) { \n    serve.write(pos);              \n    delay(15);                       \n  }\n  for (pos = 180; pos \u003e= 0; pos -= 1) { \n    serve.write(pos);              \n    delay(15);                       \n  }\n}\n\n\n\nvoid setup() {\n  Serial.begin(115200);\n  WiFi.mode(WIFI_AP_STA);\n  pinMode(2, OUTPUT);\n  serve.attach(5);\n  WiFi.disconnect();\n  preferences.begin(\"my-app\", false);\n  wifiSetup();\n  connectAWS();\n}\n \n\n\nvoid loop() {\n  client.loop();\n  if (1 == receivedJson[\"active\"]) {\n    customFunc();\n  }\n  if (WiFi.status() != WL_CONNECTED) {\n    Serial.println(\"Connecting to wifi...\");\n    delay(5000);\n    if (WiFi.status() == WL_CONNECTED) {\n      Serial.println(\"Connected...\");\n      connectAWS();\n    }\n    delay(1000);\n  }\n}\n",
  "compileRequestResp": "{\"msg\":\"Bin files uploaded successfully.\"}\n",
  "customFunction": "void customFunc() {\n  digitalWrite(2, HIGH);\n  delay(1000);\n  digitalWrite(2, LOW);\n  delay(1000);\n  for (pos = 0; pos \u003c= 180; pos += 1) { \n    serve.write(pos);              \n    delay(15);                       \n  }\n  for (pos = 180; pos \u003e= 0; pos -= 1) { \n    serve.write(pos);              \n    delay(15);                       \n  }\n}\n\n",
  "globalDeclarations": "Preferences preferences;\nWebServer server(80);\nWiFiClientSecure espClient = WiFiClientSecure();\nHTTPClient http;\nPubSubClient client(espClient);\nString fileURL = \"https://esp32-assistant-bucket.s3.eu-central-1.amazonaws.com/Container/dist/testing.ino.bin\";\nlong contentLength = 0;\nbool isValidContentType = false;\nStaticJsonDocument\u003c200\u003e receivedJson;\nServo serve;\nint pos = 0; ",
  "libraries": ["WiFi", "HTTPClient", "Preferences", "PubSubClient", "ArduinoJson", "ESP32Servo"],
  "messageHandler": "void messageHandler(char* topic, byte* payload, unsigned int length) {\n  deserializeJson(receivedJson, payload);\n  const char* type = receivedJson[\"type\"];\n  String typ(type);\n  const uint8_t value = receivedJson[\"value\"];\n  const uint8_t pin = receivedJson[\"pin\"];\n  if (typ.equals(\"led\")) {\n    digitalWrite(pin, value);\n  }\n  if (typ.equals(\"servo\")) {\n    serve.write(value);\n  }\n  if(typ.equals(\"update\")){\n    execOTA();\n  }\n}\n\n",
  "publishMessage": "void publishMessage() {\n  StaticJsonDocument\u003c200\u003e sentJson;\n  sentJson[\"type\"] = \"led\";\n  sentJson[\"value\"] = 1;\n  sentJson[\"pin\"] = 2;\n  char jsonBuffer[512];\n  serializeJson(sentJson, jsonBuffer); \n  client.publish(AWS_IOT_PUBLISH_TOPIC, jsonBuffer);\n}\n\n",
  "reply": "##Generated Libraries \n*   WiFi.h\n*   HTTPClient.h\n*   Preferences.h\n*   PubSubClient.h\n*   ArduinoJson.h\n*   ESP32Servo.h\n\n##Global Variables\n```cpp\nPreferences preferences;\nWebServer server(80);\nWiFiClientSecure espClient = WiFiClientSecure();\nHTTPClient http;\nPubSubClient client(espClient);\nString fileURL = \"https://esp32-assistant-bucket.s3.eu-central-1.amazonaws.com/Container/dist/testing.ino.bin\";\nlong contentLength = 0;\nbool isValidContentType = false;\nStaticJsonDocument\u003c200\u003e receivedJson;\nServo serve;\nint pos = 0; \n```\n##Custom Function Function \n```cpp\nvoid customFunc() {\n  digitalWrite(2, HIGH);\n  delay(1000);\n  digitalWrite(2, LOW);\n  delay(1000);\n  for (pos = 0; pos \u003c= 180; pos += 1) { \n    serve.write(pos);              \n    delay(15);                       \n  }\n  for (pos = 180; pos \u003e= 0; pos -= 1) { \n    serve.write(pos);              \n    delay(15);                       \n  }\n}\n```\n##Publish Message Function\n```cpp\nvoid publishMessage() {\n  StaticJsonDocument\u003c200\u003e sentJson;\n  sentJson[\"type\"] = \"led\";\n  sentJson[\"value\"] = 1;\n  sentJson[\"pin\"] = 2;\n  char jsonBuffer[512];\n  serializeJson(sentJson, jsonBuffer); \n  client.publish(AWS_IOT_PUBLISH_TOPIC, jsonBuffer);\n}\n```\n##Message Handler Function\n```cpp\nvoid messageHandler(char* topic, byte* payload, unsigned int length) {\n  deserializeJson(receivedJson, payload);\n  const char* type = receivedJson[\"type\"];\n  String typ(type);\n  const uint8_t value = receivedJson[\"value\"];\n  const uint8_t pin = receivedJson[\"pin\"];\n  if (typ.equals(\"led\")) {\n    digitalWrite(pin, value);\n  }\n  if (typ.equals(\"servo\")) {\n    serve.write(value);\n  }\n  if(typ.equals(\"update\")){\n    execOTA();\n  }\n}\n```\n##Setup Function\n```cpp\nvoid setup() {\n  Serial.begin(115200);\n  WiFi.mode(WIFI_AP_STA);\n  pinMode(2, OUTPUT);\n  serve.attach(5);\n  WiFi.disconnect();\n  preferences.begin(\"my-app\", false);\n  wifiSetup();\n  connectAWS();\n}\n``` \n",
  "setup": "void setup() {\n  Serial.begin(115200);\n  WiFi.mode(WIFI_AP_STA);\n  pinMode(2, OUTPUT);\n  serve.attach(5);\n  WiFi.disconnect();\n  preferences.begin(\"my-app\", false);\n  wifiSetup();\n  connectAWS();\n}\n \n"
}
